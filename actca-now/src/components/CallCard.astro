---
// --- IMPORTS ---
import type { CollectionEntry } from 'astro:content';

// --- PROPS ---
interface Props {
  call: CollectionEntry<'calls'>;
  targetID: string;
}

const { call, targetID } = Astro.props;
const { data } = call;

// Format phone number as (xxx) xxx-xxxx
function formatPhoneNumber(phone: string): string {
  const cleaned = phone.replace(/\D/g, '');
  if (cleaned.length === 10) {
    return `(${cleaned.slice(0, 3)}) ${cleaned.slice(3, 6)}-${cleaned.slice(6)}`;
  }
  return phone; // Return original if not 10 digits
}

const formattedPhone = formatPhoneNumber(data.phone);
---

<div 
  class="flex flex-col mb-4 bg-slate-900 border border-yellow-400 rounded-lg max-h-[calc(100vh-8rem)]"
  data-call-card
  data-target-id={targetID}
>
  <!-- Fixed Header Section -->
  <div class="flex-shrink-0 p-4 sm:p-6 pb-4">
    <!-- Priority Flag - Flowbite Badge -->
    {data.priority && (
      <div class="mb-3">
        <span class="bg-warning-soft text-fg-warning text-sm font-medium px-2 py-1 rounded">
          URGENT
        </span>
      </div>
    )}
    
    <!-- Official Info -->
    <div class="mb-2">
      <h3 class="text-lg sm:text-xl font-bold text-yellow-400 break-words leading-tight">{data.officialName}</h3>
      <p class="text-sm sm:text-base text-slate-400 break-words mt-1">{data.officialTitle}</p>
    </div>
  </div>
  
  <!-- Scrollable Content Area -->
  <div class="flex-1 px-4 sm:px-6 pb-4 overflow-y-auto" data-call-scroll>
    <!-- Script (sticky so it stays visible while you scroll on mobile) -->
    <div class="sticky top-0 z-10 pt-1 pb-1 mb-4 bg-slate-900">
      <p class="text-base sm:text-lg font-semibold leading-relaxed text-white break-words" data-call-script>{data.script}</p>
    </div>
    
    <!-- Flowbite Accordion for rationale -->
    <div class="mb-4" id={`accordion-rationale-${targetID}`} data-accordion="collapse" data-active-classes="bg-slate-800">
      <h2 id={`accordion-rationale-heading-${targetID}`}>
        <button 
          type="button"
          class="flex items-center justify-between w-full min-h-[48px] sm:min-h-[56px] px-3 sm:px-4 text-sm sm:text-base font-semibold text-yellow-400 bg-slate-800 border border-yellow-400 rounded-lg hover:bg-slate-700 focus:ring-4 focus:ring-yellow-400 focus:outline-none transition-colors gap-2"
          data-accordion-target={`#accordion-rationale-body-${targetID}`}
          aria-expanded="false"
          aria-controls={`accordion-rationale-body-${targetID}`}
        >
          <span class="text-left flex-shrink-0 pr-2">‚ÑπÔ∏è Rationale</span>
          <svg data-accordion-icon class="w-3 h-3 sm:w-4 sm:h-4 rotate-180 shrink-0 flex-shrink-0" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 10 6">
            <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5 5 1 1 5"/>
          </svg>
        </button>
      </h2>
      <div 
        id={`accordion-rationale-body-${targetID}`} 
        class="hidden"
        aria-labelledby={`accordion-rationale-heading-${targetID}`}
      >
        <div class="p-3 sm:p-4 mt-2 bg-slate-800 rounded-lg">
          <p class="text-sm sm:text-base leading-relaxed text-slate-300 break-words">{data.rationale}</p>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Fixed Bottom Button -->
  <div class="flex-shrink-0 p-4 sm:p-6 pt-4">
    <!-- Tap to Call Button - Flowbite Button Style -->
    <a
      href={`tel:${data.phone}`}
      class="js-call-cta inline-flex items-center justify-center w-full min-h-[56px] sm:min-h-[64px] px-4 sm:px-5 py-3 text-lg sm:text-xl md:text-2xl font-extrabold text-center text-slate-950 bg-yellow-400 rounded-2xl hover:bg-yellow-300 focus:ring-4 focus:ring-yellow-400 focus:outline-none transition-all duration-200 active:scale-[0.98] uppercase tracking-wide box-border border border-transparent shadow-xs"
      aria-label={`Call ${data.officialName} at ${formattedPhone}`}
    >
      <span class="flex items-center gap-2 sm:gap-3 flex-wrap justify-center">
        <span aria-hidden="true">üìû</span>
        <span>Tap to call</span>
        <span class="font-black opacity-90 whitespace-nowrap">{formattedPhone}</span>
      </span>
    </a>
  </div>
</div>

<script is:inline>
  // Persist scroll position so when you return from the phone dialer on mobile,
  // the script stays put instead of jumping back to the top.
  // Also track phone number clicks.
  (() => {
    console.log('CallCard script: Starting initialization...');
    
    // Wait for DOM to be ready
    const init = () => {
      const card = document.querySelector('[data-call-card]');
      console.log('CallCard script: Card element found:', !!card);
      if (!card) {
        console.warn('CallCard script: [data-call-card] not found');
        return;
      }

      const scrollEl = card.querySelector('[data-call-scroll]');
      const callLink = card.querySelector('.js-call-cta');
      const scriptEl = card.querySelector('[data-call-script]');
      const targetID = card.getAttribute('data-target-id') || 'unknown';
      
      console.log('CallCard script: Elements found:', {
        scrollEl: !!scrollEl,
        callLink: !!callLink,
        scriptEl: !!scriptEl,
        targetID: targetID
      });
      
      if (!scrollEl || !callLink) {
        console.warn('CallCard script: Missing required elements (scrollEl or callLink)');
        return;
      }

    const key = `actup:callScroll:${targetID}`;
    const zipKey = 'actup:zip';

    const save = () => {
      try {
        localStorage.setItem(key, String(scrollEl.scrollTop || 0));
      } catch {}
    };

    const restore = () => {
      try {
        const raw = localStorage.getItem(key);
        if (raw == null) return;
        const y = Number(raw);
        if (!Number.isFinite(y)) return;
        scrollEl.scrollTop = y;
      } catch {}
    };

    const normalizeZip = (input) => {
      if (typeof input !== 'string') return null;
      const trimmed = input.trim();
      if (!trimmed) return null;
      const digits = trimmed.replace(/\D/g, '');
      if (digits.length === 5) return digits;
      if (digits.length === 9) return `${digits.slice(0, 5)}-${digits.slice(5)}`;
      return null;
    };

    const getStoredZip = () => {
      try {
        const raw = localStorage.getItem(zipKey);
        return normalizeZip(raw);
      } catch {
        return null;
      }
    };

    const setStoredZip = (zip) => {
      try {
        if (!zip) return;
        localStorage.setItem(zipKey, zip);
      } catch {}
    };

    const applyZipToScript = (zip) => {
      if (!scriptEl) return;
      if (!zip) return;
      try {
        const current = scriptEl.textContent || '';
        // Replace common placeholder patterns.
        const updated = current.replace(/\[ZIP\]/g, zip).replace(/\{\{ZIP\}\}/g, zip);
        if (updated !== current) scriptEl.textContent = updated;
      } catch {}
    };

    const promptForZipIfMissing = () => {
      const existing = getStoredZip();
      if (existing) return existing;

      // In some environments (automated browsers, hardened privacy settings),
      // prompt/alert may be blocked or unsupported. In that case, just proceed.
      if (typeof window.prompt !== 'function') return null;

      // Optional, but asked at click-time for user intent/accuracy.
      // Allow cancel/blank to proceed without a ZIP.
      let zip = null;
      for (let attempt = 0; attempt < 2; attempt++) {
        let input = null;
        try {
          input = window.prompt('Enter your ZIP code (optional):', '');
        } catch {
          return null;
        }
        if (input == null) return null; // user cancelled
        const normalized = normalizeZip(input);
        if (!input.trim()) return null; // blank = skip
        if (normalized) {
          zip = normalized;
          break;
        }
        try {
          window.alert('Please enter a valid 5-digit ZIP code (or ZIP+4), or leave blank.');
        } catch {
          return null;
        }
      }

      if (zip) setStoredZip(zip);
      return zip;
    };

    // If we already have a ZIP, immediately personalize the script text.
    applyZipToScript(getStoredZip());

    // Track phone number clicks
    const trackPhoneClick = (zip) => {
      // Extract phone number from href (tel:XXXXXXXXXX)
      const phone = callLink.getAttribute('href')?.replace('tel:', '') || '';
      
      // Prepare tracking data
      const trackingData = {
        phone: phone,
        targetID: targetID,
        eventType: 'click',
        zip: zip || null
      };

      console.log('Tracking phone click:', trackingData);

      const data = JSON.stringify(trackingData);
      const endpoint = '/.netlify/functions/log-call';

      // Use fetch with keepalive for reliable delivery (works better than sendBeacon for JSON)
      fetch(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: data,
        keepalive: true // Ensures request completes even if page unloads
      })
        .then(response => {
          if (!response.ok) {
            console.error('Click tracking failed:', response.status, response.statusText);
          } else {
            return response.json().then(result => {
              console.log('Click tracked successfully:', result);
            });
          }
        })
        .catch(error => {
          console.error('Error tracking click:', error);
          // Silently fail - don't block navigation
        });
    };

    callLink.addEventListener('click', (e) => {
      save();
      const existingZip = getStoredZip();
      if (existingZip) {
        applyZipToScript(existingZip);
        trackPhoneClick(existingZip);
        return; // let default navigation to tel: happen
      }

      // Need to ask for ZIP; prevent navigation until prompt completes.
      e.preventDefault();
      const href = callLink.getAttribute('href');
      let zip = null;
      try {
        zip = promptForZipIfMissing();
        if (zip) applyZipToScript(zip);
      } catch (err) {
        console.warn('ZIP prompt failed; continuing without ZIP.', err);
      }
      trackPhoneClick(zip);

      // Continue to dialer even if prompting/tracking fails.
      if (href) window.location.href = href;
    }, { passive: false });
    
    window.addEventListener('pagehide', save, { passive: true });
    window.addEventListener('pageshow', restore, { passive: true });
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') restore();
    });

    // Initial load
    restore();
    
    // Ensure accordion is initialized
    const initAccordion = () => {
      import('flowbite').then(({ initFlowbite }) => {
        initFlowbite();
      }).catch(() => {
        // Fallback: manual accordion toggle if Flowbite fails
        const accordionButton = card.querySelector(`#accordion-rationale-heading-${targetID} button`);
        const accordionBody = card.querySelector(`#accordion-rationale-body-${targetID}`);
        if (accordionButton && accordionBody) {
          accordionButton.addEventListener('click', () => {
            const isExpanded = accordionButton.getAttribute('aria-expanded') === 'true';
            accordionButton.setAttribute('aria-expanded', !isExpanded);
            accordionBody.classList.toggle('hidden');
            const icon = accordionButton.querySelector('[data-accordion-icon]');
            if (icon) {
              icon.classList.toggle('rotate-180');
            }
          });
        }
      });
    };

    // Initialize accordion after a short delay to ensure Flowbite is available
    setTimeout(initAccordion, 100);
    
    console.log('CallCard script: Event listeners attached successfully');
    };

    // Run when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      // DOM already ready
      init();
    }
  })();
</script>

